name: Issue Copilot Routing

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  route:
    runs-on: ubuntu-latest
    steps:
      - name: Create GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout
        uses: actions/checkout@v4

      - name: Route issue to Copilot or guidance
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueBody = issue.body || '';

            const instructionsPath = path.join(process.cwd(), '.github', 'copilot-instructions.md');
            const instructions = fs.existsSync(instructionsPath)
              ? fs.readFileSync(instructionsPath, 'utf8')
              : '';

            const guidelinesPath = path.join(process.cwd(), '.github', 'guidelines.md');
            const guidelines = fs.existsSync(guidelinesPath)
              ? fs.readFileSync(guidelinesPath, 'utf8').trim()
              : '';

            const getSection = (content, header) => {
              const pattern = new RegExp(`^##\\s+${header}\\s*$`, 'm');
              const match = content.match(pattern);
              if (!match) return '';
              const startIndex = match.index + match[0].length;
              const rest = content.slice(startIndex);
              const nextHeaderMatch = rest.match(/^##\s+.+$/m);
              const endIndex = nextHeaderMatch ? startIndex + nextHeaderMatch.index : content.length;
              return content.slice(startIndex, endIndex).trim();
            };

            const applyTemplate = (template, link) => {
              if (!template) return '';
              return template.replace(/\{\{\s*link\s*\}\}/gi, link || '');
            };

            const prTemplate = getSection(instructions, 'PR_COMMENT');
            const nonPrTemplate = getSection(instructions, 'NON_PR_COMMENT');
            const noLinkTemplate = getSection(instructions, 'NO_LINK_COMMENT');

            const linkRegex = /https?:\/\/github\.com\/[^\s)\]]+/gi;

            const allTexts = [];
            if (issueBody) {
              allTexts.push({
                createdAt: issue.created_at || '1970-01-01T00:00:00Z',
                body: issueBody
              });
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100
            });

            for (const comment of comments) {
              if (comment.body) {
                allTexts.push({
                  createdAt: comment.created_at || '1970-01-01T00:00:00Z',
                  body: comment.body
                });
              }
            }

            allTexts.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

            const allLinks = [];
            for (const entry of allTexts) {
              const matches = entry.body.match(linkRegex) || [];
              for (const match of matches) {
                allLinks.push(match);
              }
            }

            const latestLink = allLinks.length > 0 ? allLinks[allLinks.length - 1] : '';

            const prMatch = latestLink.match(/https?:\/\/github\.com\/([^/]+)\/([^/]+)\/pull\/(\d+)/i);
            const repoMatch = latestLink.match(/https?:\/\/github\.com\/([^/]+)\/([^/]+)\/?$/i);

            if (!latestLink) {
              const body = applyTemplate(noLinkTemplate, '') || 'Please add a GitHub link to your PR or GitHub page.';
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body
              });
              return;
            }

            if (prMatch) {
              const [, owner, repo, pullNumber] = prMatch;
              const body = applyTemplate(prTemplate, latestLink) || `Found PR link: ${latestLink}. Starting Copilot review.`;
              const reviewBody = guidelines
                ? `Copilot review started. The review will follow these guidelines:\n\n${guidelines}`
                : 'Copilot review started. No guidelines.md found.';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body
              });

              const labelName = 'copilot-review';
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: [labelName]
                });
              } catch (error) {
                try {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: labelName,
                    color: '0e8a16',
                    description: 'Copilot review requested'
                  });
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    labels: [labelName]
                  });
                } catch (innerError) {
                  core.warning(`Unable to add label ${labelName}: ${innerError.message}`);
                }
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: Number(pullNumber),
                body: reviewBody
              });

              return;
            }

            if (repoMatch) {
              const [, targetOwner, targetRepo] = repoMatch;
              const generalBody = guidelines
                ? `Copilot review started. General guidance (from guidelines.md):\n\n${guidelines}`
                : 'Copilot review started. No guidelines.md found.';

              let externalIssueUrl = '';
              try {
                const created = await github.rest.issues.create({
                  owner: targetOwner,
                  repo: targetRepo,
                  title: 'Copilot review: general guidance',
                  body: generalBody
                });
                externalIssueUrl = created.data?.html_url || '';
              } catch (error) {
                core.warning(`Unable to create issue on ${targetOwner}/${targetRepo}: ${error.message}`);
              }

              const body = externalIssueUrl
                ? `Found GitHub repo link: ${latestLink}. Started Copilot review and opened an issue: ${externalIssueUrl}`
                : `Found GitHub repo link: ${latestLink}. Could not open an issue there (permissions may be missing).`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body
              });

              return;
            }

            const body = applyTemplate(nonPrTemplate, latestLink) || `Found GitHub link: ${latestLink}. Please provide a PR link.`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body
            });
